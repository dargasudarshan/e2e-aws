#!/bin/bash
set -ex

## TODO: Convert this bash script to use switch-case with mandatory & optional args (use getopts)

## Process util arguments 
litmus_job_label_key=$(echo $1 | cut -d "=" -f 2 | cut -d ":" -f 1)
litmus_job_label_value=$(echo $1 | cut -d "=" -f 2 | cut -d ":" -f 2)
litmus_job_file=$(echo $2 | cut -d "=" -f 2)
util_action=$(echo $3 | cut -d "=" -f 2)
litmus_result_cr_name=$(echo $4 | cut -d "=" -f 2)

# Define Cmd to get job name
jobNameCmd="kubectl get jobs -n litmus --no-headers -o jsonpath='{.items[?(@.metadata.labels.${litmus_job_label_key}==\"${litmus_job_label_value}\")].metadata.name}'"

if [[ ${util_action} == "run_job" ]]; then
  echo "Running the litmus test.."
  job_deploy_out=$(kubectl create -f ${litmus_job_file}) && \
  job_name=$(eval ${jobNameCmd}); retcode=$?
  ${utils_path}/error_handler ${retcode} msg="Unable to run litmusbook, exiting" action="exit"

elif [[ ${util_action} == "wait_on_job" ]]; then
  jobList=$(kubectl get jobs -n litmus) && \
  job_name=$(eval ${jobNameCmd}); retcode=$?
  ${utils_path}/error_handler ${retcode} msg="Unable to run litmusbook, exiting" action="exit"
  echo $jobList
fi

## Define Cmd & obtain litmus pod name 
litmusPodCmd="kubectl get pod --no-headers -n litmus -o jsonpath='{.items[?(@.metadata.labels.job-name==\"${job_name}\")].metadata.name}'"
litmus_pod=$(eval ${litmusPodCmd}); retcode=$?
${utils_path}/error_handler ${retcode} msg="Unable to find litmus test runner pod, exiting" action="exit"

## Define Cmds to get job & test state 
containerStateCmd="kubectl get pod ${litmus_pod} -n litmus -o jsonpath='{.status.containerStatuses[?(@.name==\"ansibletest\")].state}'"
jobStateCmd="kubectl get pod ${litmus_pod} --no-headers -n litmus -o custom-columns=:status.phase"
testStateCmd="kubectl get litmusresult ${litmus_result_cr_name} -n litmus --no-headers -o custom-columns=:spec.testStatus.phase"

## TODO: Consider cases where litmus pod is evicted

if [[ ${util_action} == "wait_on_result_cr" ]]; then
  
  ## Wait till the ansibletest container starts running && CR is created. 
  ## Wait until test CR is marked completed (from in-progress)

  while true; do
    cstate=$(eval ${containerStateCmd}); rc=$?
    if [[ $rc -eq 0 && ! -z $cstate ]]; then
      if [[ ! $cstate =~ 'running' ]]; then
        sleep 1
      else break;
      fi
    else
      echo "unable to get litmus container status"; exit 1
    fi
  done

  sleep 120

  while true; do
    tstate=$(eval ${testStateCmd}); rc=$?
    if [[ $rc -eq 0 && ! -z $tstate ]]; then
      if [[ ! $tstate =~ 'completed' ]]; then
        sleep 1
      else break;
      fi
    else
      echo "unable to get litmus result custom resource"; exit 1
    fi
  done

else

  ## Wait till the ansibletest container terminates && also confirm job completion status. This is done to ensure
  ## that execution of auxiliary containers such as loggers is completed. Getting the ansibletest ccontainer to completed state 
  ## satisfies the "necessary" condition for test job completion

  while true; do
    cstate=$(eval ${containerStateCmd}); rc=$?
    if [[ $rc -eq 0 && ! -z $cstate ]]; then
      if [[ ! $cstate =~ 'terminated' ]]; then 
        sleep 1
      else break;
      fi
    else 
      echo "unable to get litmus container status"; exit 1
    fi
  done
  
  while true; do
    jstate=$(eval ${jobStateCmd}); rc=$?
    if [[ $rc -eq 0 && ! -z $jstate ]]; then
      if [[ $jstate =~ 'Running' ]]; then 
        sleep 1
      else break;
      fi
    else 
      echo "unable to get litmus job status"; exit 1
    fi
  done

  echo "Litmus test run Job has completed"
fi

${utils_path}/task_delimiter;

echo "Dumping Litmus test pod logs for debug"; echo ""
kubectl logs $litmus_pod -n litmus -c ansibletest

${utils_path}/task_delimiter;
